pragma solidity ^0.4.8;


//Contract with fixed amount of possible correct submissions
//and fixed reward for every submission
contract PayForFlag {
    
    //global contract storage
    address public owner;           //deployer of the contract
    uint public max_submissions;    //max submissions allowed
    uint public cur_submissions;    //submissions iterator
    uint public fund;               //size of fund
    bool submissions_exist;         //any correct submissions in contract?
    string flag;                    //secret
    
    //constructor:
    // store owner, flag and amount of possible submissions
    function PayForFlag(string _flag, uint _ms)
    {
        owner = msg.sender;
        flag = _flag;
        max_submissions = _ms;
        cur_submissions = 0;
    }

    //sent "initial" money to contract
    function CreateFund(uint _fund) private
    {
        if (msg.sender == owner)
        {
            //submissions not exists
            // so, we can increse the fund
            if (!submissions_exist)
            {
                fund = fund + _fund;
            }
            //TODO: give difference between
            // sizes of funds to hacker who
            // already submitted
        }
    } 
    
    //destruct contract manually and send money back to
    // contract owner
    function kill()
    {
        if (msg.sender == owner)
        {
            selfdestruct(owner);
        }
    }
    
    //compare strings
    //TODO: change string logic to hashes logic
    function stringsEqual(string x, string y) private returns (bool)
    {
        return sha3(x) == sha3(y) ? true : false;
    }
    
    //main
    function SubmitFlag(string x) payable returns (bool)
    {
        //hacker's address to pay in
        address hacker = msg.sender;

        //if flag is correct send money to hacker
        //TODO: add exploit-check logic!
        if (stringsEqual(x, flag))
        {
            //prevent refund after after submission
            if (!submissions_exist)
            {
                submissions_exist = true;
            }

            //everyone receive equal peace of fund
            // (looks so strange, but just solidity best-practise)
            if(!hacker.send(fund/max_submissions))
            {
                throw;    
            }
            else
            {
                cur_submissions += 1;
                //money is over and max_submissions
                // achieved, so destruct contract
                if ((this.balance == 0) && (max_submissions == cur_submissions))
                {
                    selfdestruct(owner);
                }
            }
            
            return true;
        }
        else
        {
            return false;
        }
    }
}