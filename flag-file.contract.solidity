pragma solidity ^0.4.8;


//Contract with only one (first) submission with file cheking
contract SolveFileFlagProblem {
    
    //global contract storage
    address public owner;           // deployer of the contract
    address public admin;           // wallet from exploit testing server
    uint public divident;           // to divide fund on flag & file parts
    uint public divisor;            // to divide fund on flag & file parts
    bool submissions_exist;         // any correct submissions in contract?
    bool file_test_passed;          // exploit checked sucsessfully
    bool flag_test_passed;          // corret flag finded
    bytes32 flag;                   // secret string
    
    //constructor:
    //executes only, when contract deployed
    // store owner and flag
    //function SolveFileFlagProblem(string _flag, uint _divisor, uint _divident)
    function SolveFileFlagProblem(string _flag)
    {
        owner = msg.sender;
        flag = sha3(_flag);
        //divisor = _divisor;
        //divident = _divident;
        divisor = 2;
        divident = 3;
        file_test_passed = false;
        flag_test_passed = false;
    }

    /// This function store some ethers
    /// to contract
    function CreateFund(uint _fund) payable
    {
        // there is no submission yet
        // so, we can increase the fund
        if ((msg.sender == owner) && (!flag_test_passed))
        {
            //fund = fund + _fund;
            throw;
        }
    } 
    
    /// This function destructs the contract 
    /// and returns contract's balance to owner.
    /// Can be executed only when there is no
    /// submissions yet and only owner of contract
    function kill()
    {
        if (msg.sender == owner && !flag_test_passed && !file_test_passed)
        {
            selfdestruct(owner);
        }
    }
    
    //compare strings
    //TODO: change string logic to hashes logic
    function isFlagCorrect(string _flag) constant returns (bool)
    {
        return sha3(_flag) == flag ? true : false;
    }
    
    /// You can submit youre flag
    /// by executing this function
    function SubmitFlag(string x) payable returns (bool)
    {
        //hacker's address to pay in
        address hacker = msg.sender;

        if (!flag_test_passed && isFlagCorrect(x))
        {
            flag_test_passed = true;

            if(!hacker.send(this.balance*(divident/divisor)))
            {
                throw;    
            }
        }

        if (this.balance == 0)
        {
            selfdestruct(owner);
        }
        
    }

    /// This function can only be called by
    /// administarator's wallet or contract's owner
    function VerifyExploit() payable returns (bool)
    {
        address hacker = msg.sender;
        
        if (msg.sender == admin || msg.sender == owner)
        {
            file_test_passed = true;
            
            if (flag_test_passed)
            {
                if(!hacker.send(this.balance - this.balance*(divident/divisor)))
                {
                    throw;    
                }
            }

            if (this.balance == 0)
            {
                selfdestruct(owner);
            }

        }
        else
        {
            return false;
        }
    }

}