pragma solidity ^0.4.8;


//Contract with only one (first) submission with file cheking
contract SolveFileFlagProblem {
    
    //global contract storage
    address public owner;           // deployer of the contract
    address public admin;           // wallet from exploit testing server
    uint public fund;               // size of fund
    uint public divident;                  // to divide fund on flag & file parts
    uint public divisor;                   // to divide fund on flag & file parts
    bool submissions_exist;         // any correct submissions in contract?
    bool file_test_passed;          // exploit checked sucsessfully
    bool flag_test_passed;          // corret flag finded
    bytes32 flag;                    // secret string
    
    //constructor:
    //executes only, when contract deployed
    // store owner and flag
    function SolveFileFlagProblem(string _flag)
    {
        owner = msg.sender;
        flag = sha3(_flag);
        file_test_passed = false;
        flag_test_passed = false;
    }

    /// This function store some ethers
    /// to contract
    function CreateFund(uint _fund) private
    {
        if (msg.sender == owner)
        {
            // there is no submission yet
            // so, we can increase the fund
            if (!flag_test_passed)
            {
                fund = fund + _fund;
            }
        }
    } 
    
    /// This function destructs the contract 
    /// and returns contract's balance to owner.
    /// Can be executed only when there is no
    /// submissions yet and only owner of contract
    function kill()
    {
        if (msg.sender == owner && !flag_test_passed && !file_test_passed)
        {
            selfdestruct(owner);
        }
    }
    
    //compare strings
    //TODO: change string logic to hashes logic
    function isFlagCorrect(string _flag) constant returns (bool)
    {
        return sha3(_flag) == flag ? true : false;
    }
    
    /// You can submit youre flag
    /// by executing this function
    function SubmitFlag(string x) payable returns (bool)
    {
        //hacker's address to pay in
        address hacker = msg.sender;

        if (!flag_test_passed && isFlagCorrect(flag))
        {
            flag_test_passed = true;
            hacker.transfer(fund*(divident/divisor));
        }

        if (this.balance == 0)
        {
            selfdestruct(owner);
        }
        
    }

    /// This function can only be called by
    /// administarator's wallet or contract's owner
    function VerifyExploit() payable returns (bool)
    {
        address hacker = msg.sender;
        
        if (msg.sender == admin || msg.sender == owner)
        {
            file_test_passed = true;
            
            if (flag_test_passed)
            {
                hacker.transfer(fund - fund*(divident/divisor));
            }

            if (this.balance == 0)
            {
                selfdestruct(owner);
            }

        }
        else
        {
            return false;
        }
    }

}