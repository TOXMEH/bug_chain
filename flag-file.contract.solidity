pragma solidity ^0.4.8;


// Contract with only one (first) submission with file cheking
contract SolveFileFlagProblem {
    
    // global contract storage
    address public owner;           // deployer of the contract
    address public admin;           // wallet from exploit testing server
    uint public divisor;            // to divide fund on flag & file parts
    uint public divident;           // to divide fund on flag & file parts
    bool submissions_exist;         // any correct submissions in contract?
    bool file_test_passed;          // exploit checked sucsessfully
    bool flag_test_passed;          // corret flag finded
    bytes32 flag;                   // secret string
    
    // constructor:
    // executes only, when contract deployed
    // store owner and flag
    //function SolveFileFlagProblem(string _flag, uint _divisor, uint _divident)
    function SolveFileFlagProblem(string _flag)
    {
        owner = msg.sender;
        flag = sha3(_flag);
        //divisor = _divisor;
        //divident = _divident;
        divident = 2;
        divisor = 3;
        file_test_passed = false;
        flag_test_passed = false;
        admin = 0x02b3674D222dDee4AeE5c457F67905B9fC51d082;
    }
    
    /// This function destructs the contract 
    /// and returns contract's balance to owner.
    /// Can be executed only when there is no
    /// submissions yet and only owner of contract
    function kill()
    {
        if (msg.sender == owner && !flag_test_passed && !file_test_passed)
        {
            selfdestruct(owner);
        }
    }
    
    // verify hash
    function isFlagCorrect(string _flag) constant returns (bool)
    {
        return sha3(_flag) == flag ? true : false;
    }
    
    /// You can submit youre flag
    /// by executing this function
    function SubmitFlag(string x) payable returns (bool)
    {
        //hacker's address to pay in
        address hacker = msg.sender;

        if (!flag_test_passed && isFlagCorrect(x))
        {
            flag_test_passed = true;

            if(!hacker.send((this.balance*divident)/divisor))
            {
                throw;    
            }
        }

        if (this.balance == 0)
        {
            selfdestruct(owner);
        }
        
    }

    /// This function can only be called by
    /// administarator's wallet or contract's owner
    function VerifyExploit() payable returns (bool)
    {
        address hacker = msg.sender;
        
        if (msg.sender == admin || msg.sender == owner)
        {
            file_test_passed = true;
            
            if (flag_test_passed)
            {
                if(!hacker.send(this.balance - (this.balance*divident)/divisor))
                {
                    throw;    
                }
            }

            if (this.balance == 0)
            {
                selfdestruct(owner);
            }

        }
        else
        {
            return false;
        }
    }

    // fallback function
    function() payable { }

}